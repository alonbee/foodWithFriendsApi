## CS52 Final Project
### Foods with Friends (Server Side)

We created a separate repo for our server side code to keep our project cleaner. Modeled heavily off of Lab 5 of [Professor Tregubov's CS52 class](http://cs52.me/).

### Summary 
We built a MongoDB backend that is deployed on Heroku. Our backend stores Users, Requests, Matches (successful requests), and Chat Messages. We built various queries to create, update, and receive user data, as well as matches. Our matching algorithm connects users who have made requests for meals if they have an overlap of time.

### Architecture

On the backend, we have :
* the [CS52 Express-Babel-Mongo_node starterpack](https://github.com/dartmouth-cs52/express-babel-starter)
* Some default code from [Lab 5](http://cs52.me/assignments/lab/redux-blog+auth/)

### Setup

1. Clone the repo!
2. Navigate to the repo in your terminal.
3. `npm install` in your terminal.
4. In a separate terminal, run `mongod &` to start the daemon process of mongodb.

### Usage

1. In terminal, run `npm run dev`

### Overview of Database Schemas

* User Model - stores key information about our users. This includes personal information such as email, fullname, password, and profile image, as well as current and past matches.
* Request Model  - the data structure for a match request that a user submits. This consists of start and end time of the user's availability, location, and desired topic of conversation. User's id in User Model table is also stored to keep track of the ownership of requests.
* Match Model - stores successful requests. This differs from the Request Model in that it also stores the time that the request was matched.
* Chat Model - contains the data of an individual chat message. The chatting feature is based on  [Socketio](https://socket.io/). All messages are stored in the chat model with contents, User ID, timestamp, roomID.

### Queries

Within the User Model
* Signin: Authenticate user credentials.
* Sign Up: Capture user information and ensure the user does not already have an account.
* Update Interest: Update the user's interests and profile picture.
* Get Match History: Get past successful matches.
* Get Profile: Get the user's profile, which includes their name, profile photo, and interests, as well as all other information in the user model.
* Get Other Profile: Get another user's profile (once matched), only provides access to name, interests, profile image.
* Update Name: Allow the user to update their name.
* Update Ratings: Add ratings for the person you matched with. Allows us to verify bad actors are not on the system. (not utilized in current iteration)

Within Request/Match Model
* Instant Match: Query the Request Table(the pool for current requests) and try to find a list of match results based on time overlap and location The best match is the one with the earliest start time in the match results. Once a best match is found, the current request in both users' User Model are copied to the Match Model. And the id of these two matches appear in each other's other_match_request field of the User Model.
* Create Match Request: Create a request in the Request Table based on the info(earliest start time, latest start time, conversation topic, user's id and location) provided by the client. The id of newly created request will appear in User Model.
* Update Match Request: Updates the contents of user's current request in the Request Table.
* Get Match Result (Socket): If other_match_request in User is null, call the `Instant Match` method to check if there's any match for user's current request. Otherwise, just return the other_match_request field. Then push the other_match_request field to the match history if it's not null.
* Remove Match Request: Remove user's result from the Request Table.

Within Chat Model
* Generate roomID: Once a user requests to talk to another user(given the other user's ID), a roomID is generated by combining their IDs in the User Model. The roomID is stored in both users' User Model.
* Join a room: Join a room with the roomID generated and stored in the User Model when connecting through SocketIO.
* Send existing messages: Forward existing messages in the database with another user to the user when he connects to the server through SocketIO.
* Store message: Store the message into database from one user to another user.

### API End Point Description and Test
1 SignUp a user
  - **POST** to the `signUp` router with "email", "password", "fullname". Sever will return {"token": YOURTOKEN }.
  - e.g. `curl -X POST -H "Content-Type: application/json" -d '{"email":"allen1@gmail.com","password":"testpassword", "fullname":"munchmunch"}' "http://localhost:9090/api/signup"`

2 SignIn a user
  - **POST** to the `signin` router with the email and password. Update local token with the returned one.
  - Sever will return the user's token {"token": YOURTOKEN } if it's successful. Server will return "Unauthorized" if it's unsuccessful.
  - e.g. `curl -X POST -H "Content-Type: application/json" -d '{"email": "allen1@gmail.com","password": "testpassword"}' "http://localhost:9090/api/signin"`

3 Create a match request
  - **POST** to the `matchRequest` router with "topic", "loc", "start_time", "end_time" along with user's token.
  - **start_time** is the earliest time that user wants to start the meal, **end_time** is the latest time.
  - :warning: **IMPORTANT**: all the time posted to server should be in ISO formate in the UTC time zone. For example, if current hanover time is 2017-05-24 23:08:18, the ISO time string converted to UTC time zone is "2017-05-24T03:08:18Z".   Here is a website for reference http://coderstoolbox.net/unixtimestamp/
  - If created successfully, server will return a json `{ Message: 'Creat match request Successfully', created: 'YES' }`. If user already has a request, creation will fail and return `{ Message: 'Failed in creating match request . You have one request in the pool! Remove it before creating a new one', created: 'NO' }`. You can use the `created` to check if a match request is created successfully. In case of error, server will return `{ Message: 'Server error!', created: 'NO' }`
  - Replace the user's token when testing using the following curl cmd.

##### Example: two users post one match request per user, and they get matched because they have overlap in time.

  - User 1(00:45:29 - 00:50:29):  `curl -X POST -H "Content-Type: application/json" -H "Authorization:JUST_THE_LONG_TOKEN_STRING" -d '{"topic":"test topic", "loc": [10.5, 93.6],"start_time":"2017-05-23T00:45:29.878Z", "end_time": "2017-05-23T00:50:29.878Z"}' "http://localhost:9090/api/matchRequest"`

  - User 2(00:48:29 - 00:53:29): `curl -X POST -H "Content-Type: application/json" -H "Authorization:JUST_THE_LONG_TOKEN_STRING" -d '{"topic":"test topic", "loc": [10.5, 93.6],"start_time":"2017-05-23T00:48:29.878Z", "end_time": "2017-05-23T00:53:29.878Z"}' "http://localhost:9090/api/matchRequest"`

  - If the request is successfully created, server will reply `{ Message: 'Creat match request Successfully', created: 'YES' }` . If the request is already created, server returns `{ Message: 'Creat match request failed. The request is already in the pool!', created: 'NO' }`. If server has error, then return `{ Message: 'Server error!', created: 'NO' }`.


4 Get match result
  - Keep GET from the `getMatchResult` router during the start_time and end_time. end_time should also be the expiration time of this request.
  - Test e.g. (put the token in the following cmd)
    `curl -X GET -H "Authorization:JUST_THE_LONG_TOKEN_STRING" "http://localhost:9090/api/getMatchResult"`
  - Once the request is get matched, server will return a json like `{ Message: 'Get matched', InstaMatchedWith: bestMatch }`. If it's not matched yet, server will return a json like `{ Message: 'No InstaMatch Found. Please wait for 5mins.', InstaMatchedWith: '' }` Note that the InstaMatchedWith field is empty in this case.

5 Remove current request
  - GET from the `removeMatchRequest` router when the client find the request has expired which means current time has reached to the end_time of user's request or user has tapped the cancel button while waiting for a match.  
  - e.g. (put the token in the following cmd) `curl -X GET -H "Authorization:JUST_THE_LONG_TOKEN_STRING" "http://localhost:9090/api/removeMatchRequest"`
  - If successful, server should return a json like `{ Message: 'Removed Current Match Request!', removed: 'YES' }`. If user doesn't have current request, server should return `{ Message: 'User does\'t Current Match Request', removed: 'NO' }`

7 Update user profile

-To update USER name
1. `curl -X POST -H "Content-Type: application/json" -d '{"fullname":"abc","email": "abc@test.com","password": "password"}' "http://localhost:9090/api/signup"`
2. `curl -X POST -H "Content-Type: application/json" -d '{"email": "abc@test.com","password": "password"}' "http://localhost:9090/api/signin"`
3. `curl -X PUT -H "Content-Type: application/json" -H "Authorization: ENTER LONG AUTHORIZATION TOKEN HERE" -d '{"fullname": "Changed"}' "http://localhost:9090/api/updatename"`

- To update USER Interests AND/OR Profile Image
`curl -X PUT -H "Content-Type: application/json" -d '{
    "interests": ["dogs" ,"cats"],
    "profile_image": "INSERT_IMAGE_URL",
    "User":"INSERT USER ID HERE"
}' "http://localhost:9090/api/interests"`

- To test USER Signup
`curl -X POST -H "Content-Type: application/json" -d '{
    "email": "mailgurkaran@gmail.com",
    "password":  "test",
    "fullname": "gurkaran singh"
}' "http://localhost:9090/api/signup"`

-To test USER ratings (put post-match rating into user object)
1. `curl -X POST -H "Content-Type: application/json" -d '{"fullname":"abc","email": "abc@test.com","password": "password"}' "http://localhost:9090/api/signup"`
2. `curl -X POST -H "Content-Type: application/json" -d '{"email": "abc@test.com","password": "password"}' "http://localhost:9090/api/signin"`
3. `curl -X PUT -H "Content-Type: application/json" -H "Authorization: ENTER LONG AUTHORIZATION TOKEN HERE" -d '{"rating": "5"}' "http://localhost:9090/api/rating"`



8 Get other user profile information
1. `curl -X POST -H "Content-Type: application/json" -d '{"fullname":"abc","email": "abc@test.com","password": "password"}' "http://localhost:9090/api/signup"`
2. `curl -X POST -H "Content-Type: application/json" -d '{"email": "abc@test.com","password": "password"}' "http://localhost:9090/api/signin"`
3. `curl -X GET -H "Authorization:ENTER LONG AUTHORIZATION TOKEN HERE" "http://localhost:9090/api/user/ENTER_DESIRED_USER_ID_HERE"`
e.g. `"http://localhost:9090/api/user/592602266083bd4642ea6e01"`


### How to test

Using Motcha/Chai:
 - Run `mongod &` in your terminal. In the root folder, do `npm install` then `npm test`.
 - The test cases should be able to pass. You can check the testcases in the test/matchRequest.js

or Using Curl locally:  
 - Run `mongod &` in your terminal. In the root folder, do `npm install` then `npm test`.
 - First signUp a user and signIn. Create an instant match request with time range of (45,50). Remember to put the token in the curl which is returned after singIn. Should return no match.
 `curl -X POST -H "Content-Type: application/json" -H "Authorization:JUST_THE_LONG_TOKEN_STRING" -d '{"topic":"test topic", "loc": [10.5, 93.6],"start_time":"2017-05-23T00:45:29.878Z", "end_time": "2017-05-23T00:50:29.878Z"}' "http://localhost:9090/api/matchRequest"`

 - Then add a user with time range of (51,56). Should return no match because the time is not overlapped with any user.
 `curl -X POST -H "Content-Type: application/json" -H "Authorization:JUST_THE_LONG_TOKEN_STRING" -d '{"topic":"test topic", "loc": [10.5, 93.6],"start_time":"2017-05-23T00:51:29.878Z", "end_time": "2017-05-23T00:56:29.878Z"}' "http://localhost:9090/api/matchRequest"`

 - Then add a user with time range of (47,52). Should return the best match: the user with time [45,50].
 `curl -X POST -H "Content-Type: application/json" -H "Authorization:JUST_THE_LONG_TOKEN_STRING" -d '{"topic":"test topic", "loc": [10.5, 93.6],"start_time":"2017-05-23T00:47:29.878Z", "end_time": "2017-05-23T00:52:29.878Z"}' "http://localhost:9090/api/matchRequest"`


### Deploy to Heroku - will deploy to to https://munchees.herokuapp.com/api/
1. Navigate to the repo in your terminal
2. `git remote add heroku`
3. `git push heroku master`

### What worked
* Having background on authentication, building schemas, and doing backend routing from the labs (particularly 4 and 5) was incredibly helpful.
* We were able to hack together a backend that delivered on all our primary functionality specifications in 3 weeks!

### What didn’t work so well
* SocketIO was great for chat but quite a challenge to get working for matching
* We were ambitious early on, planning to filter based on location, conversation topics, and interests. Given our timeline, we weren’t able to get all these features and would have to leave them for a future iteration. 
* There were some rocky moments synchronizing results between multiple users

### Authors


Team Members

* Allison Chuang
* Jane Lee
* Gurkaran Singh
* Abby Starr
* Allen Wu

Core Mentor

* Jason Feng


## Acknowledgments

* Professor Tregubov for advice and guidance on our project
* Chatroom inspiration - https://github.com/vinnyoodles/react-native-socket-io-example
